03.07.2016
----------
By the way, 12 0x266016 has FixOrCompare(AP1J + AB36, AP46)
and it comes out that AP46 is a better play?!

26.06.2016
----------
Working on 2, PossiblyFixRankRun():

It's reasonably simple, but not right so far.  (45,168 lines)
I think a combination of two ideas can fix it:

a) Introduce a shadow low card, made from leader's lowest card,
only when even the lowest card can theoretically be run as a finesse.
So LHO must have a higher and a lower card, pard must have a lower
card, and RHOmax must be lower (or void), and length[side] > 1.

This makes a special path through Holding.cpp.  Mainly it limits
partner's plays (he can't duck even if that would win).
And LHO must duck (otherwise we'd not need the special play).

Do this is leader's first play, to get a sensible solution in first.

b) The run should then probably go back to including both sides.

AQT97 / - / 86 / KJ5 will become PA1T + PA4- or PA1Q + PA48,
and the former will win.

AJ7 / - / QT9 / K7 will adjust Q to T or 9, but the shadow play
will only use AQJ.

A8 / 7654 / KJT / Q4 will adjust J to T, but the shadow play will
only use AKJ.

No need for the cashers check anymore then?


19.06.2016
----------
There are several known issues:

1. The double finesse is a bit tricky.

   AQTx            AQTx
KJx     -      KJ8       -
   98xx            9xxx

The 8 allows PA1Q + (either PA3T or PP39).
Without the 8, PA1T + (either PA3- or PP39).
With 9876, we cannot avoid getting the first which is actually worse.
One could even argue that it should be PP38 in that case.  Or not.
Perhaps the solution is to allow a special lead which we "promise" to
overtake.  It only applies when even the lowest lead can be run.
So needs to beat lhomin, also rhomax (can be void), also pardmin.


2. PA + BP + another A segment
Split into PP + A segment, or PA without A segment.
The code already exists, but is not turned on.





13, 5acef
    AKQ6
7532       JT
    984

Should there be a play for unblocking 98 and hooking 6?

05.06.2016
----------
About 52,854 rank issues left for now.
Two changes not turned on at the moment:
1. DefList special rank fix, probably should go again.
2. CompareInit, change commented out for now.

First do these for completeness:

0x102e, 80
0x1083, 320
0x1115, 60
0x11a8, 33
0x11ac, 111 (two sub-cases, 11223 and 1122)
0x11bd, 196
0x11bf, 153
0x11d3, 30
0x11e1, 285
0x12a4, 105
0x1365-a, 19

0x1188-a, 33 cases (two sub-cases, 1123 and 1124)
0x11ab  , 71 cases (two sub-cases, 1123 and 1124)


01.06.2016
----------
9, 0x388b
    AKT8
Q6       -
    J97

9-6: A beats 8, PA4T or PP3J+AA1-
9-6-8: PB48 becomes PP48
Then PA4T or PP48 together seem to beat PP3J+AA1-.
This is OK for PP3J, but probably not for PA4J as J > T.
So we should carry along both.
Then in the end, PP49 should lose to BA4T, leaving the symmetric soln.

So
1. Find the place where MergeDeclarer of
3 0 2 -1
PP4T or PA3J+AA1- merged with PA4T+PP48 becomes only the latter.
Probably some too soft merge.
No, actually it's the regular AltList + of PP48 over PP3J+AA1- !
Ugh.

2. Think about 3 6 8 -1 (9-Q-A): Should it be rank J or T-9?


16.05.2016
----------
The rank detector in single.cpp can optionally not recurse, but
instead only output a single specimen of each new cone (i.e. only
when the top of the cone is new, even if it doesn't agree with the
current cone).  Or something like that.


Clean up many branches with separate.pl, once ranks are OK.


07.05.2016
----------
* Not happy with Holding.cpp, run >= 3, but hard...

Split LoopHold to make it faster to compile (derived).

Output examples.txt for each holdCtr value.

Maybe shouldn't manually enter rank (derive automatically also
for Simple moves).


Have more generic Set function than Set1123...


13. cc9257
    AQT7
KJ2     8543
    96

Get AA1A, PA2Q, PA1Q + PA2T.
This is kind of OK, but we'd prefer PA1T + PA2-.
Here it may be a play comparison issue (for defender).
In general it may have to be some kind of post-processing.
Otherwise the 9 matters for a play with rank T...


11, cca2b vs cca8b

   AQT7            AQT6
KJ4      -     KJ4      -
   9865            9875

In latter case, 7-J-Q:
PA1A +
(AA1A or PP39 or PA3T)
There is no branch where the 8 wins a trick.
But there WOULD HAVE BEEN if he hadn't covered.
Then it would go PA47.

Same if we lead the 8-J-Q:  Here the later 9 becomes an 8.
And if we lead the 9-J-Q: Here the 9 becomes an 8 straight away.

PossiblyFixRank in Holding.cpp, line 624:
Should it be h-1 or h, perhaps?

---

Annotate all branches with an example.
No more "return false" branches.
Go back to G51.
Count the complex ones left over of each type (G00 .. G63).


Maybe make an input option to control creation of track.txt file.
option goes in MakeComplexSingleMove.

Get examples of broken results from recursion, by looking in
simpleDiff.txt.

Wrapper may need to be modified for one Solver (see 13, 0x38a47f
below!).

-h 7 probably causes early change in singles.  So we should find
those changes and include them as simple moves!

There are more simple moves than I see, e.g. BA5A (asymmetric).

Search for PROBLEM in LoopHold.cpp


defMerged shrinks
-----------------
There are a couple of places where we merge to less than the product
of the two numbers of defenses:
9, e4a5
13, ea247f
They can be found where MergeSidesHard is called.

Ranks
-----
13, 38a47f
    AKT6
Q432      75
    J98

def1 has 6 in it, seems right.
def2: PP39+AA1- or PA4T.
West doesn't cover when T AND 9 are held.  How to recognize?
The merge then loses the 6: AA1A + PA36 <= PA4T (or PA49, or whatever).
This is actually true.  No reason to start with ace if you have a
AP move from elsewhere.
This now segfaults when called from the command line!


Remove GetKeyNew and GetKey
Change internal data structure of Header
Find bounds in Header on new internal data
Experiment with hashes, also end

Thoughts on two-move data structure
-----------------------------------
Look at counts of moves and #d, #a.
Reduce size of arrays.

Can have individual hash functions, or smaller ones, for each type.


PLAN
====
* Get the algorithmic parts completely clean and solid


Other code
----------

**** Think about storage for QT_ACE and QT_PARD separately,
     and also LHO/RHO (single 32b field, at least A/P?)


20.09.2015
----------
Reduction thoughts:
* Distinguish NT and suit play?!  Seems tough
* Defense leads to first trick

Approach:
* Get the simple counts down to 0
* Get the less-simple counts down to 0

SimpleMoves:
* Does loop have to be over declLen, or can we go to 2 loops, not 3?

LoopHold:
* Split full-suit combos out of the 64 functions into
  64 other functions
* Have a single central dispatch function which returns
  one of three histogram codes if it works
* Check that all branches are still active; renumber


General:
* Profile Guided Optimization, blogs.msdn.com/b/vcblog/archive/2008/11/12/pogo.aspx
  msdn.microsoft.com/en-us/library/fsk896zz.aspx
* No more const #define's
* Also compile with g++
* Make command-line interface so that we "never" have to recompile
* As few ints as possible, as few static_casts as possible


-------


20.06.2015
----------
Stopped28(): Rewrite with pa, pl, pp, pr

Call it HIST_STOPPED
Think about a HIST_SYMM (EQUAL and also DIFF)

25.05.15
--------
CashoutPard() must also deal with one-sided cashes.
So it must return something that enables BAnr.


Hashing
-------
a. Trick (maxTricks 4 bits, cashTricks 2*4 bits)
b. Rank (maxRanks 4 bits, cashRanks 2*4 bits)
c. Case (something with d and a)
d. Minrank (b with minRanks, 4 bits more)

        Bits    Reduced rbits   Buckets Avg length
a       12      132      8       132    210.94  Trick
b       12      399      9                      Rank
c                20      5                      Case
d       16      593     10                      Minrank

a*b                     17      1859     17.64
a*c                     13       371    100.50
b*c                     14       907     54.64  RankCase
a*d                     18      2384     11.68
c*d

a*(b*c)                 18      3100      9.90
a*(c*d)                 19?     3725      7.11
a*(c*d)                 19?     3442      6.72  With fix

The move structs have now gotten so large that they take a long 
time to copy around.


Output files
------------
Loop over NUMBOTTOMS to see when low ranks matter.
determine overall size of two file tables
output the moves (how many) as code to compile, or as third table?
functions for writing and reading them
time the lookup of all individual suits (no caching)
choose a sensible cutoff between file size and speed
